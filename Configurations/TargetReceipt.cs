using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Xml.Serialization;
using BuildToolUtilities;

namespace BuildTool
{
	// Arbitrary property name/value which metadata from the build scripts can be passed on to downstream tasks
	[Serializable]
	public sealed class ReceiptProperty
	{
		[XmlAttribute]
		public string PropertyName;

		[XmlAttribute]
		public string PropertyValue;

		public ReceiptProperty(string InPropertyName, string InPropertyValue)
		{
			PropertyName = InPropertyName;
			PropertyValue = InPropertyValue;
		}
	}

	// Stores a record of a built target, with all metadata that other tools may need to know about the build.
	// Stores information about a compiled target. Mirror of the TargetReceipt.h/cpp class generated by UBT.
	[Serializable]
	public sealed class TargetReceipt
	{
		public FileReference ProjectFile; // Path to the project file for this target
		public DirectoryReference ProjectDir; // The project directory

		public string TargetName;    // The name of this target
		public BuildTargetPlatform Platform;      // Which platform the target is compiled for
		public TargetConfiguration Configuration; // Which configuration this target is compiled in
		public TargetType TargetType;    // The type of the target
		public string Architecture;  // Which platform the target is compiled for

		public BuildVersion Version; // Version information for this target.
		public FileReference Launch;  // The exectuable to launch for this target

		public List<BuildProduct> BuildProducts = new List<BuildProduct>(); // The build products which are part of this target
		public RuntimeDependencyList RuntimeDependencies = new RuntimeDependencyList(); // All the runtime dependencies that this target relies on
		public List<ReceiptProperty> AdditionalProperties = new List<ReceiptProperty>(); // Additional build properties passed through from the module rules

		public TargetReceipt
		(
			FileReference InProjectFile,
			string InTargetName,
			TargetType InTargetType,
			BuildTargetPlatform InPlatform,
			TargetConfiguration InConfiguration,
			BuildVersion InVersion,
			string InArchitecture
		)
		{
			ProjectFile = InProjectFile;
			ProjectDir = DirectoryReference.FromFile(InProjectFile);
			TargetName = InTargetName;
			Platform = InPlatform;
			Configuration = InConfiguration;
			TargetType = InTargetType;
			Version = InVersion;
			Architecture = InArchitecture;
		}

		public TargetReceipt(TargetReceipt Other)
		{
			Launch = Other.Launch;
			foreach (BuildProduct OtherBuildProduct in Other.BuildProducts)
			{
				BuildProducts.Add(new BuildProduct(OtherBuildProduct));
			}
			foreach (RuntimeDependency OtherRuntimeDependency in Other.RuntimeDependencies)
			{
				RuntimeDependencies.Add(new RuntimeDependency(OtherRuntimeDependency));
			}
			AdditionalProperties.AddRange(Other.AdditionalProperties);
		}


		// Adds a build product to the receipt.
		// Does not check whether it already exists.
		// TODO : Make BuildProducts Container to convert Dictionary to unique.
		public BuildProduct AddBuildProduct(FileReference PathToBuildProduct, BuildProductType InBuildProductType)
		{
			BuildProduct NewBuildProduct = new BuildProduct(PathToBuildProduct, InBuildProductType);
			BuildProducts.Add(NewBuildProduct);
			return NewBuildProduct;
		}

		public void Merge(TargetReceipt OtherToBeMerged)
		{
			foreach (BuildProduct OtherBuildProduct in OtherToBeMerged.BuildProducts)
			{
				BuildProducts.Add(OtherBuildProduct);
			}
			foreach (RuntimeDependency OtherRuntimeDependency in OtherToBeMerged.RuntimeDependencies)
			{
				if (!RuntimeDependencies.Any(x => x.Path == OtherRuntimeDependency.Path))
				{
					RuntimeDependencies.Add(OtherRuntimeDependency);
				}
			}
		}

		// Inserts variables to make a file relative to $(EngineDir) or $(ProjectDir)
		// EngineDir  - Value of the $(EngineDir)  variable.
		// ProjectDir - Value of the $(ProjectDir) variable.
		private static string InsertPathVariables(FileReference DestFile, DirectoryReference EngineDir, DirectoryReference ProjectDir)
		{
			if (!DirectoryReference.Exists(EngineDir))
			{
				throw new BuildException("{0} doesn't exist.", EngineDir);
			}
			if (!DirectoryReference.Exists(ProjectDir))
			{
				throw new BuildException("{1} doesn't exist.", ProjectDir);
			}

			if (DestFile.IsUnderDirectory(EngineDir))
			{
				return Tag.JSONField.EngineDir + "/" + DestFile.MakeRelativeTo(EngineDir).Replace(Path.DirectorySeparatorChar, '/');
			}
			else if (ProjectDir != null && DestFile.IsUnderDirectory(ProjectDir))
			{
				return Tag.JSONField.ProjectDir + "/" + DestFile.MakeRelativeTo(ProjectDir).Replace(Path.DirectorySeparatorChar, '/');
			}
			else
			{
				return DestFile.FullName;
			}
		}

		// Inserts variables to make a file relative to $(EngineDir) or $(ProjectDir)
		// Path       - The path to insert variables into.
		// EngineDir  - Value of the $(EngineDir)  variable.
		// ProjectDir - Value of the $(ProjectDir) variable.
		private static FileReference ExpandPathVariables(string Path, DirectoryReference EngineDir, DirectoryReference ProjectDir)
		{
			if (Path.StartsWith(Tag.JSONField.EngineDir, StringComparison.InvariantCultureIgnoreCase))
			{
				return new FileReference(EngineDir.FullName + Path.Substring(Tag.JSONField.EngineDir.Length));
			}

			if (ProjectDir != null && 
				Path.StartsWith(Tag.JSONField.ProjectDir, StringComparison.InvariantCultureIgnoreCase))
			{
				return new FileReference(ProjectDir.FullName + Path.Substring(Tag.JSONField.ProjectDir.Length));
			}

			return new FileReference(Path);
		}

		// Returns the standard path to the build receipt for a given target
		public static FileReference GetDefaultPath(DirectoryReference BaseDir, string TargetName, BuildTargetPlatform Platform, TargetConfiguration Configuration, string BuildArchitecture)
		{
			// Get the architecture suffix. Platforms have the option of overriding whether to include this string in filenames.
			string ArchitectureSuffix = null;

			if (BuildArchitecture.HasValue() && 
				BuildPlatform.GetBuildPlatform(Platform).RequiresArchitectureSuffix())
			{
				ArchitectureSuffix = BuildArchitecture;
			}

			// Build the output filename
			if (String.IsNullOrEmpty(ArchitectureSuffix) && 
				Configuration == TargetConfiguration.Development)
			{
				return FileReference.Combine(BaseDir, Tag.Directory.Binaries, Platform.ToString(), String.Format("{0}.target", TargetName));
			}
			else
			{
				return FileReference.Combine(BaseDir, Tag.Directory.Binaries, Platform.ToString(), String.Format("{0}-{1}-{2}{3}" + Tag.Ext.Target, TargetName, Platform.ToString(), Configuration.ToString(), ArchitectureSuffix));
			}
		}

		// Determine whether a BuildProduct Type is NonUFS or DebugNonUFS
		public static StagedFileType GetStageTypeFromBuildProductType(BuildProduct BuildProduct)
		{
			if (BuildProduct.Type == BuildProductType.SymbolFile ||
				BuildProduct.Type == BuildProductType.MapFile)
			{
				return StagedFileType.RawDebugFile;
			}
			return StagedFileType.RawFile;
		}

		// Checks the Additional properties for one with the given name that matches the given value
		public bool HasValueForAdditionalProperty(string PropertyName, string ValueToCompare)
		{
			// get all properties with the given name?
			IEnumerable<ReceiptProperty> Results = AdditionalProperties.Where(x => x.PropertyName == PropertyName);
			foreach (ReceiptProperty Property in Results)
			{
				// does the property value match?
				if (Property.PropertyValue.Equals(ValueToCompare, StringComparison.InvariantCultureIgnoreCase))
				{
					return true;
				}
			}

			return false;
		}

		// Read a receipt from disk.
		public static TargetReceipt Read(FileReference Location)
		{
			return Read(Location, BuildTool.EngineDirectory);
		}

		// Read a receipt from disk.
		public static TargetReceipt Read(FileReference InJSONFileToRead, DirectoryReference EngineDir)
		{
			JsonObject RawJSONObject = JsonObject.Read(InJSONFileToRead);
			TargetReceipt Receipt;
			{
				// Read the initial fields
				string TargetName = RawJSONObject.GetStringField(Tag.JSONField.TargetName);
				TargetType TargetType = RawJSONObject.GetEnumField<TargetType>(Tag.JSONField.TargetType);
				BuildTargetPlatform Platform = BuildTargetPlatform.Parse(RawJSONObject.GetStringField(Tag.JSONField.Platform));
				TargetConfiguration Configuration = RawJSONObject.GetEnumField<TargetConfiguration>(Tag.JSONField.Configuration);

				// Try to read the build version
				if (!BuildVersion.TryParse(RawJSONObject.GetObjectField(Tag.JSONField.Version), out BuildVersion Version))
				{
					throw new JsonParseException("Invalid 'Version' field");
				}

				// Read the project path
				FileReference ProjectFile = null;

				if (RawJSONObject.TryGetStringField(Tag.JSONField.Project, out string RelativeProjectFile))
				{
					ProjectFile = FileReference.Combine(InJSONFileToRead.Directory, RelativeProjectFile);
				}

				// Read the launch executable
				if (!RawJSONObject.TryGetStringField(Tag.JSONField.Architecture, out string Architecture))
				{
					Architecture = "";
				}

				// Create the receipt
				Receipt = new TargetReceipt(ProjectFile, TargetName, TargetType, Platform, Configuration, Version, Architecture);
			}

			// Get the project directory
			DirectoryReference ProjectDir = Receipt.ProjectDir;

			// Read the launch executable
			if (RawJSONObject.TryGetStringField(Tag.JSONField.Launch, out string Launch))
			{
				Receipt.Launch = ExpandPathVariables(Launch, EngineDir, ProjectDir);
			}

			// Read the build products
			if (RawJSONObject.TryGetObjectArrayField(Tag.JSONField.BuildProducts, out JsonObject[] BuildProductObjects))
			{
				foreach (JsonObject ItrBuildProductObject in BuildProductObjects)
				{
					if (ItrBuildProductObject.TryGetStringField(Tag.JSONField.Path, out string Path) && ItrBuildProductObject.TryGetEnumField(Tag.JSONField.Type, out BuildProductType Type))
					{
						FileReference File = ExpandPathVariables(Path, EngineDir, ProjectDir);

						// ItrBuildProductObject.TryGetStringField(Module, out string Module);

						Receipt.AddBuildProduct(File, Type);
					}
				}
			}

			// Read the runtime dependencies
			if (RawJSONObject.TryGetObjectArrayField(Tag.JSONField.RuntimeDependencies, out JsonObject[] RuntimeDependencyObjects))
			{
				foreach (JsonObject RuntimeDependencyObject in RuntimeDependencyObjects)
				{
					if (RuntimeDependencyObject.TryGetStringField(Tag.JSONField.Path, out string Path))
					{
						FileReference File = ExpandPathVariables(Path, EngineDir, ProjectDir);

						if (!RuntimeDependencyObject.TryGetEnumField(Tag.JSONField.Type, out StagedFileType Type))
						{
							// Previous format included an optional IgnoreIfMissing flag, which was only used for debug files. We can explicitly reference them as DebugNonUFS files now.
							if (RuntimeDependencyObject.TryGetBoolField(Tag.JSONField.IgnoreIfMissing, out bool bIgnoreIfMissing))
							{
								bIgnoreIfMissing = false;
							}

							Type = bIgnoreIfMissing ?
								StagedFileType.RawDebugFile :
								StagedFileType.RawFile;
						}

						Receipt.RuntimeDependencies.Add(File, Type);
					}
				}
			}

			// Read the additional properties
			if (RawJSONObject.TryGetObjectArrayField(Tag.JSONField.AdditionalProperties, out JsonObject[] AdditionalPropertyObjects))
			{
				foreach (JsonObject AdditionalPropertyObject in AdditionalPropertyObjects)
				{
					if (AdditionalPropertyObject.TryGetStringField(Tag.JSONField.Name, out string Name))
					{
						if (AdditionalPropertyObject.TryGetStringField(Tag.JSONField.Value, out string Value))
						{
							Receipt.AdditionalProperties.Add(new ReceiptProperty(Name, Value));
						}
					}
				}
			}

			return Receipt;
		}

		public static bool TryRead(FileReference FileName, out TargetReceipt Receipt)
		{
			return TryRead(FileName, BuildTool.EngineDirectory, out Receipt);
		}

		public static bool TryRead(FileReference FileName, DirectoryReference EngineDir, out TargetReceipt Receipt)
		{
			if (!FileReference.Exists(FileName))
			{
				Receipt = null;
				return false;
			}

			try
			{
				Receipt = Read(FileName, EngineDir);
				return true;
			}
			catch (Exception)
			{
				Receipt = null;
				return false;
			}
		}

		public void Write(FileReference OutputFileName)
		{
			Write(OutputFileName, BuildTool.EngineDirectory);
		}

		public void Write(FileReference OutputFileName, DirectoryReference EngineDir)
		{
			using (JsonWriter Writer = new JsonWriter(OutputFileName.FullName))
			{
				Writer.WriteObjectStart();
				Writer.WriteValue(Tag.JSONField.TargetName, TargetName);
				Writer.WriteValue(Tag.JSONField.Platform, Platform.ToString());
				Writer.WriteValue(Tag.JSONField.Configuration, Configuration.ToString());
				Writer.WriteValue(Tag.JSONField.TargetType, TargetType.ToString());
				Writer.WriteValue(Tag.JSONField.Architecture, Architecture);

				if (ProjectFile != null)
				{
					Writer.WriteValue(Tag.JSONField.Project, ProjectFile.MakeRelativeTo(OutputFileName.Directory).Replace(Path.DirectorySeparatorChar, '/'));
				}

				if (Launch != null)
				{
					Writer.WriteValue(Tag.JSONField.Launch, InsertPathVariables(Launch, EngineDir, ProjectDir));
				}

				Writer.WriteObjectStart(Tag.JSONField.Version);
				Version.WriteProperties(Writer);
				Writer.WriteObjectEnd();

				Writer.WriteArrayStart(Tag.JSONField.BuildProducts);
				foreach (BuildProduct BuildProduct in BuildProducts)
				{
					Writer.WriteObjectStart();
					Writer.WriteValue(Tag.JSONField.Path, InsertPathVariables(BuildProduct.Path, EngineDir, ProjectDir));
					Writer.WriteValue(Tag.JSONField.Type, BuildProduct.Type.ToString());
					Writer.WriteObjectEnd();
				}
				Writer.WriteArrayEnd();

				Writer.WriteArrayStart(Tag.JSONField.RuntimeDependencies);

				foreach (RuntimeDependency RuntimeDependency in RuntimeDependencies)
				{
					Writer.WriteObjectStart();
					Writer.WriteValue(Tag.JSONField.Path, InsertPathVariables(RuntimeDependency.Path, EngineDir, ProjectDir));
					Writer.WriteValue(Tag.JSONField.Type, RuntimeDependency.Type.ToString());
					Writer.WriteObjectEnd();
				}

				Writer.WriteArrayEnd();

				if (0 < AdditionalProperties.Count)
				{
					Writer.WriteArrayStart(Tag.JSONField.AdditionalProperties);
					foreach (ReceiptProperty AdditionalProperty in AdditionalProperties)
					{
						Writer.WriteObjectStart();
						Writer.WriteValue(Tag.JSONField.Name, AdditionalProperty.PropertyName);
						Writer.WriteValue(Tag.JSONField.Value, AdditionalProperty.PropertyValue);
						Writer.WriteObjectEnd();
					}
					Writer.WriteArrayEnd();
				}

				Writer.WriteObjectEnd();
			}
		}
	}
}
