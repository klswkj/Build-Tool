using System;
using System.Collections.Generic;
using BuildToolUtilities;

namespace BuildTool
{
	public enum BuildProductType
	{
		Executable,       // An executable file
		DynamicLibrary,   // A dynamically loaded module.
		SymbolFile,       // Not required for the executable to run.
		MapFile,          // Not required for the executable to run.
		RequiredResource, // A resource file which was generated by the build and is required for the executable to run.
		BuildResource,    // A build resource which was generated by the build, but is not required for the executable to run.
		Package           // A package which can be deployed on device (eg. *.apk for Android, *.stub for iOS)
	}

	// A file that was created as part of the build process
	[Serializable]
	public sealed class BuildProduct
	{
		public FileReference    Path; // Path to the file.
		public BuildProductType Type; // Type of the build product.

		// Private constructor, for serialization.
		private BuildProduct()
		{
		}

		public BuildProduct(FileReference InPath, BuildProductType InType)
		{
			Path = InPath;
			Type = InType;
		}

		public BuildProduct(BuildProduct Other)
		{
			Path = Other.Path;
			Type = Other.Type;
		}

		// Convert this object to a string, for debugging.
		// <returns>Path to this build product</returns>
		public override string ToString()
		{
			return Path.ToString();
		}
	}

	// Compilation Error!!!
	// How a file may be staged
	public enum StagedFileType
	{
		CustomPAKFile, // (=UFS) Only accessed through custom filesystem functions; may be included in a PAK file.
		RawFile,       // (NonUFS) Must be kept as part of the loose filesystem.
		RawDebugFile,  // (=DebugNonUFS) Debug file which must be kept as part of the loose filesystem.

		// System file which must be kept as part of the loose filesystem. 
		// System files are not subject to being automatic remapping or renaming by the platform layer.
		RawSystemfile, // (=SystemNonUFS)
	}

	// Information about a file which is required by the target at runtime, 
	// and must be moved around with it.
	[Serializable]
	public sealed class RuntimeDependency
	{
		// The file that should be staged. 
		// Should use $(EngineDir) and $(ProjectDir) variables as a root, 
		// so that the target can be relocated to different machines.
		public FileReference Path;

		public StagedFileType Type; // How to stage this file.

		// Private constructor, for serialization.
		private RuntimeDependency()
		{
		}

		public RuntimeDependency(FileReference InPath, StagedFileType InType = StagedFileType.RawFile)
		{
			Path = InPath;
			Type = InType;
		}

		public RuntimeDependency(RuntimeDependency InOther)
		{
			Path = InOther.Path;
			Type = InOther.Type;
		}

		public override string ToString()
		{
			return Path.ToString();
		}
	}

	// List of runtime dependencies, with convenience methods for adding new items
	[Serializable]
	public sealed class RuntimeDependencyList : List<RuntimeDependency>
	{
		public RuntimeDependencyList()
		{
		}

		public RuntimeDependencyList(IEnumerable<RuntimeDependency> Other) : base(Other)
		{
		}

		public void Add(FileReference InPathWithWildCards, StagedFileType InType)
		{
			Add(new RuntimeDependency(InPathWithWildCards, InType));
		}
	}
}
