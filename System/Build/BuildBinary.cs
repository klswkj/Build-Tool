using System;
using System.Collections.Generic;
using System.Linq;
using BuildToolUtilities;

// UEBuildModule
//     ├─────────── ModuleRules   ┬─  PluginInfo          Plugin
//     │                          ├─  ModuleRulesContext  Context
//     │                          ├─  ReadOnlyTargetRules Target
//     │                          └─  bool                bTreatAsEngineModule, bUseRTTI, bUseAVX, bEnforceIWYU, bAddDefaultIncludePaths, bPrecompile, bUsePrecompiled
//     │
//     └─────────── UEBuildBinary ┬── bool                bAllowExports, bUsePrecompiled
//                                ├── UEBuildModuleCPP    PrimaryModule(launch module)
//                                └── List<UEBuildModule> LinkTogetherModules

namespace BuildTool
{
	// All binary types generated by UBT
	enum BuildBinaryType
	{
		Executable,         // An executable
		DynamicLinkLibrary, // A dynamic library (.dll, .dylib, or .so)	
		StaticLibrary,      // A static library (.lib or .a)
		Object,             // Object files
		PrecompiledHeader,  // Precompiled header
	}

	// A binary built by UBT.
	internal sealed class BuildBinary
	{
		public BuildBinaryType Type; // The type of binary to build
		public DirectoryReference OutputDir; // Output directory for this binary
		public List<FileReference> OutputFilePaths; // The output file path. This must be set before a binary can be built using it.
		public readonly List<BuildModule> LinkTogetherModules = new List<BuildModule>(); // List of modules to link together into this executable
		
		private List<string> DependentLinkLibraries; // Cached list of dependent link libraries.

		// Returns the OutputFilePath if there is only one entry in OutputFilePaths
		public FileReference OutputFilePath
		{
			get
			{
				if (OutputFilePaths.Count != 1)
				{
					throw new BuildException("Attempted to use {0}.OutputFilePath property, but there are multiple (or no) OutputFilePaths. " +
						"You need to handle multiple in the code that called this (size = {1})", nameof(BuildBinary), OutputFilePaths.Count);
				}
				return OutputFilePaths[0];
			}
		}

		// The intermediate directory for this binary. 
		// Modules should create separate intermediate directories below this.
		// Must be set before a binary can be built using it.
		public DirectoryReference IntermediateDirectory;

		public bool bAllowExports                  = false; // If true, build exports lib
		public bool bCreateImportLibrarySeparately = false; // If true, create a separate import library

		// If true, creates an additional console application.
		// Hack for Windows, where it's not possible to conditionally inherit a parent's console Window depending on how
		// the application is invoked; you have to link the same executable with a different subsystem setting.
		public bool bBuildAdditionalConsoleApp = false;

		public bool bUsePrecompiled;

		// The primary module that this binary was constructed for. 
		// For executables, this is typically the launch module.
		public readonly BuildModuleCPP PrimaryModule;

		public BuildBinary
		(
			BuildBinaryType          Type,
			IEnumerable<FileReference> OutputFilePaths,
			DirectoryReference         IntermediateDirectory,
			bool                       bAllowExports,
			bool                       bBuildAdditionalConsoleApp,
			BuildModuleCPP           PrimaryModule,
			bool                       bUsePrecompiled
		)
		{
			this.Type                       = Type;
			this.OutputDir                  = OutputFilePaths.First().Directory;
			this.OutputFilePaths            = new List<FileReference>(OutputFilePaths);
			this.IntermediateDirectory      = IntermediateDirectory;
			this.bAllowExports              = bAllowExports;
			this.bBuildAdditionalConsoleApp = bBuildAdditionalConsoleApp;
			this.PrimaryModule              = PrimaryModule;
			this.bUsePrecompiled            = bUsePrecompiled;
			
			LinkTogetherModules.Add(PrimaryModule);
		}

		// Creates all the modules referenced by this target.
		public void CreateAllDependentModules(BuildModule.CreateModuleDelegate CreateModule)
		{
			foreach (BuildModule Module in LinkTogetherModules)
			{   // CreateModule = BuildTarget::FindOrCreateModuleByName
				Module.RecursivelyCreateModules(CreateModule, "Target");
			}
		}

		// Builds the binary.
		public List<FileItem> Build
		(
			ReadOnlyTargetRules   InReadOnlyTargetRules, 
			ToolChain             ToolChain, 
			CppCompileEnvironment CompileEnvironment, 
			LinkEnvironment       LinkEnvironment, 
			FileReference         SingleFileToCompile, // may be null.
			ISourceFileWorkingSet WorkingSet, 
			DirectoryReference    OutExeDirectory, 
			IActionGraphBuilder   Graph
		)
		{
			// Return nothing if we're using precompiled binaries. If we're not linking, we might want just one module to be compiled (eg. a foreign plugin), so allow any actions to run.
			if (bUsePrecompiled && 
				!(InReadOnlyTargetRules.LinkType == TargetLinkType.Monolithic && InReadOnlyTargetRules.bDisableLinking))
			{
				return new List<FileItem>();
			}

			// Setup linking environment.
			LinkEnvironment BinaryLinkEnvironment = 
			SetupBinaryLinkEnvironment
			(
                InReadOnlyTargetRules,
                ToolChain,
                LinkEnvironment,
                CompileEnvironment,
                SingleFileToCompile,
                WorkingSet,
                OutExeDirectory,
                Graph
			);

			// If we're generating projects, we only need include paths and definitions, there is no need to run the linking logic.
			if (ProjectFileGenerator.bGenerateProjectFiles)
			{
				return BinaryLinkEnvironment.InputFiles;
			}

			// If linking is disabled, our build products are just the compiled object files
			if (InReadOnlyTargetRules.bDisableLinking)
			{
				return BinaryLinkEnvironment.InputFiles;
			}

			// Generate import libraries as a separate step
			List<FileItem> OutputFiles = new List<FileItem>();

			if (bCreateImportLibrarySeparately)
			{
				// Mark the link environment as cross-referenced.
				BinaryLinkEnvironment.bIsCrossReferenced = true;

				if (BinaryLinkEnvironment.Platform != BuildTargetPlatform.Mac &&
					BinaryLinkEnvironment.Platform != BuildTargetPlatform.Linux &&
					BinaryLinkEnvironment.Platform != BuildTargetPlatform.LinuxAArch64)
				{
					// Create the import library.
					OutputFiles.AddRange(ToolChain.LinkAllFiles(BinaryLinkEnvironment, true, Graph));
				}
			}

			// Link the binary.
			FileItem[] Executables = ToolChain.LinkAllFiles(BinaryLinkEnvironment, false, Graph);
			OutputFiles.AddRange(Executables);

			// Save all the output items for this binary. This is used for hot-reload, and excludes any items added in PostBuild (such as additional files copied into the app).
			if(InReadOnlyTargetRules.LinkType == TargetLinkType.Modular)
			{
				Graph.SetOutputItemsForModule(PrimaryModule.ModuleRuleFileName, OutputFiles.ToArray());
			}

			// Produce additional console app if requested
			if (bBuildAdditionalConsoleApp)
			{
				// Produce additional binary but link it as a console app
				LinkEnvironment ConsoleAppLinkEvironment = new LinkEnvironment(BinaryLinkEnvironment)
				{
					bIsBuildingConsoleApplication = true,
					WindowsEntryPointOverride     = Tag.Argument.LinkOption.WinMainCRTStartup, // For WinMain() instead of "main()" for Launch module
					OutputFilePaths               = OutputFilePaths.Select(Path => GetAdditionalConsoleAppPath(Path)).ToList()
				};

				// Link the console app executable
				FileItem[] ConsoleAppOutputFiles = ToolChain.LinkAllFiles(ConsoleAppLinkEvironment, false, Graph);
				OutputFiles.AddRange(ConsoleAppOutputFiles);

				foreach (FileItem Executable in ConsoleAppOutputFiles)
				{
					OutputFiles.AddRange(ToolChain.PostBuild(Executable, ConsoleAppLinkEvironment, Graph));
				}
			}

			foreach (FileItem Executable in Executables)
			{
				OutputFiles.AddRange(ToolChain.PostBuild(Executable, BinaryLinkEnvironment, Graph));
			}

			return OutputFiles;
		}

		// Gets all the runtime dependencies Copies all the runtime dependencies from any modules in
		public void PrepareRuntimeDependencies
		(
            List<RuntimeDependency>                  RuntimeDependencies,
            Dictionary<FileReference, FileReference> TargetFileToSourceFile,
            DirectoryReference                       OutputEXEDirectory
		)
		{
			foreach(BuildModule Module in LinkTogetherModules)
			{
				foreach (ModuleRules.RuntimeDependency Dependency in Module.ModuleRule.RuntimeDependencies.Inner)
				{
					if(Dependency.SourcePath == null)
					{
						// Expand the target path
						string ExpandedPath = Module.ExpandPathVariables(Dependency.Path, OutputDir, OutputEXEDirectory);
						if (FileFilter.FindWildcardIndex(ExpandedPath) == -1)
						{
							RuntimeDependencies.Add(new RuntimeDependency(new FileReference(ExpandedPath), Dependency.StagedType));
						}
						else
						{
							RuntimeDependencies.AddRange(FileFilter.ResolveWildcard(ExpandedPath).Select(x => new RuntimeDependency(x, Dependency.StagedType)));
						}
					}
					else
					{
						// Parse the source and target patterns
						FilePattern SourcePattern = new FilePattern(BuildTool.EngineSourceDirectory, Module.ExpandPathVariables(Dependency.SourcePath, OutputDir, OutputEXEDirectory));
						FilePattern TargetPattern = new FilePattern(BuildTool.EngineSourceDirectory, Module.ExpandPathVariables(Dependency.Path, OutputDir, OutputEXEDirectory));

						// Resolve all the wildcards between the source and target paths
						Dictionary<FileReference, FileReference> Mapping;
						try
						{
							Mapping = FilePattern.CreateMapping(null, ref SourcePattern, ref TargetPattern);
						}
						catch(FilePatternException Ex)
						{
							ExceptionUtils.AddContext(Ex, "while creating runtime dependencies for module '{0}'", Module.ModuleRuleFileName);
							throw;
						}

						// Add actions to copy everything
						foreach(KeyValuePair<FileReference, FileReference> Pair in Mapping)
						{
							if(!TargetFileToSourceFile.TryGetValue(Pair.Key, out FileReference ExistingSourceFile))
							{
								TargetFileToSourceFile[Pair.Key] = Pair.Value;
								RuntimeDependencies.Add(new RuntimeDependency(Pair.Key, Dependency.StagedType));
							}
							else if(ExistingSourceFile != Pair.Value)
							{
								throw new BuildException("Runtime dependency '{0}' is configured to be staged from '{1}' and '{2}'", Pair.Key, Pair.Value, ExistingSourceFile);
							}
						}
					}
				}
			}
		}

		// Called to allow the binary to modify the link environment of a different binary
		// containing a module that depends on a module in this binary.
		public void SetupDependentLinkEnvironment(LinkEnvironment DependentLinkEnvironment)
		{
			// Cache the list of libraries in the dependent link environment between calls.
			// We typically run this code path many times for each module.
			if (DependentLinkLibraries == null)
			{
				DependentLinkLibraries = new List<string>();
				foreach (FileReference OutputFilePath in OutputFilePaths)
				{
					FileReference LibraryFileName;
					if (Type == BuildBinaryType.StaticLibrary                           ||
						DependentLinkEnvironment.Platform == BuildTargetPlatform.Mac   ||
						DependentLinkEnvironment.Platform == BuildTargetPlatform.Linux ||
						DependentLinkEnvironment.Platform == BuildTargetPlatform.LinuxAArch64)
					{
						LibraryFileName = OutputFilePath;
					}
					else
					{
						LibraryFileName = FileReference.Combine(IntermediateDirectory, OutputFilePath.GetFileNameWithoutExtension() + Tag.Ext.Lib); ;
					}
					DependentLinkLibraries.Add(LibraryFileName.FullName);
				}
			}
			DependentLinkEnvironment.AdditionalLibraries.AddRange(DependentLinkLibraries);

#if CHECKINGPCLAUNCH
			// If we're linking against static library containing the launch module on windows, we need to add the compiled resource separately. We can't link it through the static library.
			if (Type == BuildBinaryType.StaticLibrary && LinkTogetherModules.Any(x => x.ModuleRuleFileName == "Launch") && 
				(PrimaryModule.ModuleRule.Target.Platform == BuildTargetPlatform.Win32 || PrimaryModule.ModuleRule.Target.Platform == BuildTargetPlatform.Win64))
			{
				FileReference ResourceFileRef = FileReference.Combine(IntermediateDirectory, "Launch", "PCLaunch.rc.res");
				DependentLinkEnvironment.InputFiles.Add(FileItem.GetItemByFileReference(ResourceFileRef));
			}
#endif
		}

		// Called to allow the binary to find game modules.
		public List<BuildModule> FindHotReloadModules()
		{
			List<BuildModule> GameModules = new List<BuildModule>();
			foreach (BuildModule Module in LinkTogetherModules)
			{
				if(Module.ModuleRule.Context.bCanHotReload)
				{
					GameModules.Add(Module);
				}
			}

            return 0 < GameModules.Count? null : GameModules;
        }

        // Generates a list of all modules referenced by this binary
        public List<BuildModule> GetAllDependencyModules(bool bIncludeDynamicallyLoaded, bool bIgnoreCircularDependencies)
		{
			List<BuildModule>    ReferencedModules       = new List<BuildModule>();
			HashSet<BuildModule> IgnoreReferencedModules = new HashSet<BuildModule>();

			foreach (BuildModule Module in LinkTogetherModules)
			{
				if (!IgnoreReferencedModules.Contains(Module))
				{
					IgnoreReferencedModules.Add(Module);

#warning
					Module.RecursivelyGetAllDependencyModules
					(
						ReferencedModules, 
						IgnoreReferencedModules, 
						bIncludeDynamicallyLoaded, 
						bIgnoreCircularDependencies, 
						OutbThisModuleDirectDependencies: false
					);

					ReferencedModules.Add(Module);
				}
			}

			return ReferencedModules;
		}

		// Generates a list of all modules referenced by this binary
		public void FindModuleReferences(Dictionary<BuildModule, BuildModule> ReferencedBy)
		{
			List<BuildModule> ReferencedModules = new List<BuildModule>();
			foreach(BuildModule Module in LinkTogetherModules)
			{
				ReferencedModules.Add(Module);
				ReferencedBy.Add(Module, null);
			}

			List<BuildModule>    DirectlyReferencedModules = new List<BuildModule>();
			HashSet<BuildModule> VisitedModules            = new HashSet<BuildModule>();

			for(int Idx = 0; Idx < ReferencedModules.Count; ++Idx)
			{
				BuildModule SourceModule = ReferencedModules[Idx];

				// Find all the direct references from this module
				DirectlyReferencedModules.Clear();
				SourceModule.RecursivelyGetAllDependencyModules(DirectlyReferencedModules, VisitedModules, false, false, true);

				// Set up the references for all the new modules
				foreach(BuildModule DirectlyReferencedModule in DirectlyReferencedModules)
				{
					if(!ReferencedBy.ContainsKey(DirectlyReferencedModule))
					{
						ReferencedBy.Add(DirectlyReferencedModule, SourceModule);
						ReferencedModules.Add(DirectlyReferencedModule);
					}
				}
			}
		}

		// Sets whether to create a separate import library to resolve circular dependencies for this binary
		public void SetCreateImportLibrarySeparately(bool bInCreateImportLibrarySeparately)
		{
			bCreateImportLibrarySeparately = bInCreateImportLibrarySeparately;
		}

		// Adds a module to the binary.
		public void AddModule(BuildModule Module)
		{
			if (!LinkTogetherModules.Contains(Module))
			{
				LinkTogetherModules.Add(Module);
			}
		}

		// Gets all build products produced by this binary
		public void GetBuildProducts
		(
            ReadOnlyTargetRules Target,
            ToolChain PlatformToolChain,
            Dictionary<FileReference, BuildProductType> BuildProductsToType,
            bool bCreateDebugInfo
		)
		{
			// Add all the precompiled outputs
			foreach(BuildModuleCPP Module in LinkTogetherModules.OfType<BuildModuleCPP>())
			{
				if(Module.ModuleRule.bPrecompile)
				{
					if(Module.GeneratedCodeDirectory != null && DirectoryReference.Exists(Module.GeneratedCodeDirectory))
					{
						foreach(FileReference GeneratedCodeFile in DirectoryReference.EnumerateFiles(Module.GeneratedCodeDirectory))
						{
							// Exclude timestamp files, since they're always updated and cause collisions between builds
							if(!GeneratedCodeFile.GetFileName().Equals("Timestamp", StringComparison.OrdinalIgnoreCase) && !GeneratedCodeFile.HasExtension(".cpp"))
							{
								BuildProductsToType.Add(GeneratedCodeFile, BuildProductType.BuildResource);
							}
						}
					}
					if(Target.LinkType == TargetLinkType.Monolithic)
					{
						FileReference PrecompiledManifestLocation = Module.PrecompiledManifestLocation;
						BuildProductsToType.Add(PrecompiledManifestLocation, BuildProductType.BuildResource);

						PrecompiledManifest ModuleManifest = PrecompiledManifest.Read(PrecompiledManifestLocation);
						foreach(FileReference OutputFile in ModuleManifest.OutputFiles)
						{
							if(!BuildProductsToType.ContainsKey(OutputFile))
							{
								BuildProductsToType.Add(OutputFile, BuildProductType.BuildResource);
							}
						}
					}
				}
			}

			// Add all the binary outputs
			if(!Target.bDisableLinking)
			{
				// Get the type of build products we're creating
				BuildProductType OutputType = BuildProductType.RequiredResource;
				switch (Type)
				{
					case BuildBinaryType.Executable:
						OutputType = BuildProductType.Executable;
						break;
					case BuildBinaryType.DynamicLinkLibrary:
						OutputType = BuildProductType.DynamicLibrary;
						break;
					case BuildBinaryType.StaticLibrary:
						OutputType = BuildProductType.BuildResource;
						break;
				}

				// Add the primary build products
				string[] DebugExtensions = BuildPlatform.GetBuildPlatform(Target.Platform).GetDebugInfoExtensions(Target, Type);
				foreach (FileReference OutputFilePath in OutputFilePaths)
				{
					AddBuildProductAndDebugFiles(OutputFilePath, OutputType, DebugExtensions, BuildProductsToType, PlatformToolChain, bCreateDebugInfo);
				}

				// Add the console app, if there is one
				if (Type == BuildBinaryType.Executable && bBuildAdditionalConsoleApp)
				{
					foreach (FileReference OutputFilePath in OutputFilePaths)
					{
						AddBuildProductAndDebugFiles(GetAdditionalConsoleAppPath(OutputFilePath), OutputType, DebugExtensions, BuildProductsToType, PlatformToolChain, bCreateDebugInfo);
					}
				}

				// Add any additional build products from the modules in this binary, including additional bundle resources/dylibs on Mac.
				List<string> Libraries = new List<string>();
				List<BuildBundleResource> BundleResources = new List<BuildBundleResource>();
				GatherAdditionalResources(Libraries, BundleResources);

				// Add any extra files from the toolchain
				PlatformToolChain.ModifyBuildProducts(Target, this, Libraries, BundleResources, BuildProductsToType);
			}
		}

        // Adds a build product and its associated debug file to a receipt.
        private static void AddBuildProductAndDebugFiles
		(
            FileReference OutputFile,
            BuildProductType OutputType,
            string[] DebugExtensions, // may be null.
            Dictionary<FileReference, BuildProductType> BuildProductsToType,
            ToolChain ToolChain,
            bool bCreateDebugInfo
		)
		{
			BuildProductsToType.Add(OutputFile, OutputType);

			if (bCreateDebugInfo && ToolChain.ShouldAddDebugFileToReceipt(OutputFile, OutputType))
			{
				foreach (string DebugExtension in DebugExtensions)
				{
					if (DebugExtension.HasValue())
					{
						// @todo this could be cleaned up if we replaced Platform.GetDebugExtensions() with ToolChain.GetDebugFiles(OutputFile)
						// would need care in MacToolchain tho, so too risky for now
						BuildProductsToType.Add(ToolChain.GetDebugFile(OutputFile, DebugExtension), BuildProductType.SymbolFile);
					}
				}
			}
		}

		// Enumerates resources which the toolchain may need may produced additional build products from.
		// Some platforms (eg. Mac, Linux) can link directly against .so/.dylibs, but they are also copied to the output folder by the toolchain.
		public void GatherAdditionalResources(List<string> RequireThisModuleLibraries, List<BuildBundleResource> BundleResources)
		{
			foreach(BuildModule Module in LinkTogetherModules)
			{
				Module.GatherAdditionalResources(RequireThisModuleLibraries, BundleResources);
			}
		}

		// Helper function to get the console app BinaryName-Cmd.exe filename based on the binary filename.
		public static FileReference GetAdditionalConsoleAppPath(FileReference BinaryExecutablePath)
		{
			DirectoryReference Directory = BinaryExecutablePath.Directory;
			if (Directory.FullName.EndsWith(Tag.Ext.App + "/" + Tag.Directory.Contents + "/" + Tag.Directory.MacOS))
			{
				Directory = Directory.ParentDirectory.ParentDirectory.ParentDirectory;
			}

			return FileReference.Combine(Directory, BinaryExecutablePath.GetFileNameWithoutExtension() + "-Cmd" + BinaryExecutablePath.GetExtension());
		}

		// Checks whether the binary output paths are appropriate for the distribution
		// level of its direct module dependencies
		public bool CheckRestrictedFolders
		(
            List<DirectoryReference> RootDirectories,
            Dictionary<BuildModule, Dictionary<RestrictedFolder, DirectoryReference>> ModuleRestrictedFolderCache
		)
		{
			// Find all the modules we depend on
			Dictionary<BuildModule, BuildModule> ModuleReferencedBy = new Dictionary<BuildModule, BuildModule>();
			FindModuleReferences(ModuleReferencedBy);

			// Loop through each of the output binaries and check them separately
			bool bResult = true;
			foreach (FileReference OutputFilePath in OutputFilePaths)
			{
				// Find the base directory for this binary
				DirectoryReference BaseDir = RootDirectories.FirstOrDefault(x => OutputFilePath.IsUnderDirectory(x));
				if (BaseDir == null)
				{
					continue;
				}

				// Find the permitted restricted folder references under the base directory
				List<RestrictedFolder> BinaryFolders = RestrictedFolders.FindPermittedRestrictedFolderReferences(BaseDir, OutputFilePath.Directory);

				List<RestrictedFolder> AliasedBinaryFolders = new List<RestrictedFolder>();
				foreach (RestrictedFolder BinaryFolder in BinaryFolders)
				{
					if (PrimaryModule.AliasRestrictedFolders.TryGetValue(BinaryFolder.ToString(), out string Alias))
					{
						foreach (RestrictedFolder Folder in RestrictedFolder.GetValues())
						{
							if (Folder.ToString().Equals(Alias))
							{
								AliasedBinaryFolders.Add(Folder);
							}
						}
					}
				}
				BinaryFolders.AddRange(AliasedBinaryFolders);

				// Check all the dependent modules
				foreach(BuildModule Module in ModuleReferencedBy.Keys)
				{
					// Find the restricted folders for this module
					if (!ModuleRestrictedFolderCache.TryGetValue(Module, out Dictionary<RestrictedFolder, DirectoryReference> ModuleRestrictedFolders))
					{
						ModuleRestrictedFolders = Module.FindRestrictedFolderReferences(RootDirectories);
						ModuleRestrictedFolderCache.Add(Module, ModuleRestrictedFolders);
					}

					// Write errors for any missing paths in the output files
					foreach (KeyValuePair<RestrictedFolder, DirectoryReference> Pair in ModuleRestrictedFolders)
					{
						if(!BinaryFolders.Contains(Pair.Key))
						{
							List<string> ReferenceChain = new List<string>();
							for(BuildModule ReferencedModule = Module; ReferencedModule != null; ReferencedModule = ModuleReferencedBy[ReferencedModule])
							{
								ReferenceChain.Insert(0, ReferencedModule.ModuleRuleFileName);
							}
							Log.TraceError("Output binary \"{0}\" is not in a {1} folder, but references \"{2}\" via {3}.", OutputFilePath, Pair.Key.ToString(), Pair.Value, String.Join(" -> ", ReferenceChain));
							bResult = false;
						}
					}
				}
			}
			return bResult;
		}

		// Write information about this binary to a JSON file
		public void ExportJson(JsonWriter Writer)
		{
			Writer.WriteValue(nameof(BuildBinary.OutputFilePath), OutputFilePath.FullName);
			Writer.WriteValue(nameof(BuildBinary.Type), Type.ToString());

			Writer.WriteArrayStart(nameof(BuildModule.ModuleRuleFileName));
			foreach(BuildModule Module in LinkTogetherModules)
			{
				Writer.WriteValue(Module.ModuleRuleFileName);
			}
			Writer.WriteArrayEnd();
		}

		private static bool IsBuildingDll(BuildBinaryType Type)
		{
			return Type == BuildBinaryType.DynamicLinkLibrary;
		}

		private static bool IsBuildingLibrary(BuildBinaryType Type)
		{
			return Type == BuildBinaryType.StaticLibrary;
		}

		public CppCompileEnvironment OnlyCopyBuildingType(CppCompileEnvironment GlobalCompileEnvironment)
		{
			CppCompileEnvironment BinaryCompileEnvironment = new CppCompileEnvironment(GlobalCompileEnvironment)
			{
				bIsBuildingDLL     = IsBuildingDll(Type),
				bIsBuildingLibrary = IsBuildingLibrary(Type)
			};
			return BinaryCompileEnvironment;
		}

		private LinkEnvironment SetupBinaryLinkEnvironment
		(
            ReadOnlyTargetRules   Target,
            ToolChain             ToolChain,
            LinkEnvironment       LinkEnvironment,
            CppCompileEnvironment CompileEnvironment,
            FileReference         SingleFileToCompile,
            ISourceFileWorkingSet WorkingSet,
            DirectoryReference    ExeDir,
            IActionGraphBuilder   Graph
		)
		{
			LinkEnvironment       OutBinaryLinkEnvironment = new LinkEnvironment(LinkEnvironment);
			CppCompileEnvironment BinaryCompileEnvironment = OnlyCopyBuildingType(CompileEnvironment);

			if (Target.ProjectFile != null &&
				CompileEnvironment.bUseSharedBuildEnvironment &&
				IntermediateDirectory.IsUnderDirectory(Target.ProjectFile.Directory))
			{
				BinaryCompileEnvironment.bUseSharedBuildEnvironment = false;
			}

			HashSet<BuildModule> LinkEnvironmentVisitedModules = new HashSet<BuildModule>();
			List<BuildBinary>    BinaryDependencies            = new List<BuildBinary>();

			foreach (BuildModule Module in LinkTogetherModules)
			{
				List<FileItem> LinkInputFiles;
				if (Module.Binary == null || Module.Binary == this)
				{
					// Compile each module.
					Log.TraceVerbose("Compile module: " + Module.ModuleRuleFileName);

					LinkInputFiles = Module.Compile(Target, ToolChain, BinaryCompileEnvironment, SingleFileToCompile, WorkingSet, Graph);

					// Save the module outputs. In monolithic builds, this is just the object files.
					if (Target.LinkType == TargetLinkType.Monolithic)
					{
						Graph.SetOutputItemsForModule(Module.ModuleRuleFileName, LinkInputFiles.ToArray());
					}

					// NOTE: Because of 'Shared PCHs', in monolithic builds the same PCH file may appear as a link input multiple times for a single binary.
					// We'll check for that here, and only add it once.
					// This avoids a linker warning about redundant .obj files.
					foreach (FileItem LinkInputFile in LinkInputFiles)
					{
						if (!OutBinaryLinkEnvironment.InputFiles.Contains(LinkInputFile))
						{
							OutBinaryLinkEnvironment.InputFiles.Add(LinkInputFile);
						}
					}

					// Force a reference to initialize module for this binary
					if(Module.ModuleRule.bRequiresImplementModule.Value)
					{
						OutBinaryLinkEnvironment.IncludeFunctions.Add(String.Format(Tag.Argument.ModuleImplement + "{0}", Module.ModuleRuleFileName));
					}
				} // See : BinaryLinkEnvironemnt.InputFiles
				else
				{
					BinaryDependencies.Add(Module.Binary);
				}

				// Allow the module to modify the link environment for the binary.
				Module.SetupPrivateLinkEnvironment(this, OutBinaryLinkEnvironment, BinaryDependencies, LinkEnvironmentVisitedModules, ExeDir);
			}

			// Allow the binary dependencies to modify the link environment.
			foreach (BuildBinary BinaryDependency in BinaryDependencies)
			{
				BinaryDependency.SetupDependentLinkEnvironment(OutBinaryLinkEnvironment);
			}

			// Set the link output file.
			OutBinaryLinkEnvironment.OutputFilePaths = OutputFilePaths.ToList();

			// Set whether the link is allowed to have exports.
			OutBinaryLinkEnvironment.bHasExports = bAllowExports;

			// Set the output folder for intermediate files
			OutBinaryLinkEnvironment.IntermediateDirectory = IntermediateDirectory;

			// Put the non-executable output files (PDB, import library, etc) in the same directory as the production
			OutBinaryLinkEnvironment.OutputDirectory = OutputFilePaths[0].Directory;

			// Setup link output type
			OutBinaryLinkEnvironment.bIsBuildingDLL = IsBuildingDll(Type);
			OutBinaryLinkEnvironment.bIsBuildingLibrary = IsBuildingLibrary(Type);

			// If we don't have any resource file, use the default or compile a custom one for this module
			if(OutBinaryLinkEnvironment.Platform.IsInGroup(BuildPlatformGroup.Windows))
			{
				// Figure out if this binary has any custom resource files.
				// Hacky check to ignore the resource file in the Launch module,
				// since it contains dialogs that the engine needs and always needs to be included.
				FileItem[] CustomResourceFiles = 
				OutBinaryLinkEnvironment.InputFiles.Where
				(
					x => 
					x.FileDirectory.HasExtension(Tag.Ext.Res) && 
					!x.FileDirectory.FullName.EndsWith("\\" + Tag.Module.Engine.Launch + "\\" + Tag.Binary.PCLaunch + Tag.Ext.RcRes, StringComparison.OrdinalIgnoreCase)
				).ToArray();

				if(CustomResourceFiles.Length == 0)
				{
					if(0 < OutBinaryLinkEnvironment.DefaultResourceFiles.Count)
					{
						// Use the default resource file if possible
						OutBinaryLinkEnvironment.InputFiles.AddRange(OutBinaryLinkEnvironment.DefaultResourceFiles);
					}
					else
					{
						// Get the intermediate directory
						DirectoryReference ResourceIntermediateDirectory = OutBinaryLinkEnvironment.IntermediateDirectory;

						// Create a compile environment for resource files
						CppCompileEnvironment ResourceCompileEnvironment = new CppCompileEnvironment(BinaryCompileEnvironment);

						// @todo: This should be in some Windows code somewhere...
						// Set the original file name macro; used in Default.rc2 to set the binary metadata fields.
						ResourceCompileEnvironment.Definitions.Add(Tag.CppContents.Def.OriginalFileName + OutputFilePaths[0].GetFileName() + "\"");

						// Set the other version fields
						ResourceCompileEnvironment.Definitions.Add(String.Format(Tag.CppContents.Def.BuiltFormChangeList+ "{0}", Target.Version.Changelist));
						ResourceCompileEnvironment.Definitions.Add(String.Format(Tag.CppContents.Def.BuildVersion + "{0}", Target.BuildVersion));

						// Otherwise compile the default resource file per-binary, so that it gets the correct ORIGINAL_FILE_NAME macro.
						FileItem DefaultResourceFile = FileItem.GetItemByFileReference(FileReference.Combine(BuildTool.EngineDirectory, Tag.Directory.Build, Tag.Directory.Windows, Tag.Directory.Resources, "Default.rc2"));
						CPPOutput DefaultResourceOutput = ToolChain.CompileRCFiles(ResourceCompileEnvironment, new List<FileItem> { DefaultResourceFile }, ResourceIntermediateDirectory, Graph);
						
						if (DefaultResourceOutput != null && DefaultResourceOutput.ObjectFiles.Count != 0)
						{
							OutBinaryLinkEnvironment.InputFiles.AddRange(DefaultResourceOutput.ObjectFiles);
						}
					}
				}
			}

			// Add all the common resource files
			OutBinaryLinkEnvironment.InputFiles.AddRange(OutBinaryLinkEnvironment.CommonResourceFiles);

			return OutBinaryLinkEnvironment;
		}

		// ToString implementation
		public override string ToString()
		{
			return OutputFilePath.FullName;
		}
	}
}
